const { OpenAI } = require("openai");
const axios = require("axios");
const moment = require("moment-timezone");
const { EventEmitter } = require("events");
const FunctionCallingPrompt = require("../models/function_calling_prompt");
const fs = require("fs");
const path = require("path");
require("dotenv").config();
const config = {
  apiKey: process.env.OpenAI_API,
};

const openai = new OpenAI(config);

const savePrompt = async (name, message, extra, session) => {
  try {
    const date = new Date();
    const prompt = {
      name,
      time: `${date.getDate()}/${date.getMonth()}/${date.getFullYear()} ${
        date.getHours()
      }:${date.getMinutes()}`,
      message,
    };
    if (extra) {
      prompt.extra = "Generated by, OpenAI";
    }
    const functionCallingPromptCollection = await new FunctionCallingPrompt(prompt);
    const functionCallingPrompt = await functionCallingPromptCollection.save({session});
    return functionCallingPrompt;
  } catch (err) {
    throw err;
  }
};

const getAllPrompt = async (session) => {
  try {
    const functionCallingPrompts = await FunctionCallingPrompt.find().session(session).lean();
    if (functionCallingPrompts) {
      return functionCallingPrompts;
    } else {
      return [];
    }
  } catch (err) {
    throw err;
  }
};

const lookUpTime = async (location) => {
  try {
    const response = await axios.get(`http://worldtimeapi.org/api/timezone/${location}`);
    const { datetime } = response.data;
    const dateTime = moment.tz(datetime, location);
    const formattedString = `The current time in ${location} is ${dateTime}`;
    return formattedString;
  } catch (err) {
    throw err;
  }
}

const createAssistant = async (model, name, instructions, tools, session) => {
  const assistant = await openai.beta.assistants.create({
    name: "Bot Math Tutor - Yasir",
    instructions: "You are a personal math tutor. You explain math and write and run code for it. You also no coding well",
    model,
    tools: [
      {
        type: "code_interpreter"
      },
      {
        type: "function",
        function: {
          name: "lookUpTime",
          description: "get the current time in a given location",
          parameters: {
            type: "object",
            properties: {
              location: {
                type: "string",
                description: "the location e.g. Islamabad, Pakistan. But it should be written in a timezone like Europe/Paris"
              }
            },
            required: ["location"]
          }
        }
      }
    ]
  });
  // TODO: Save this assistant in the database
  return assistant;
};

const listOfAssistants = async () => {
  try {
    const assistants = await openai.beta.assistants.list();
    return assistants;
  } catch (err) {
    throw err;
  }
};

const getAssistantById = async (id) => {
  try {
    const assistent = await openai.beta.assistants.retrieve(id);
    return assistent;
  } catch (err) {
    throw err; 
  }
};

class EventHandler extends EventEmitter {
  constructor(client, eventEmitter) {
    super();
    this.client = client;
    this.eventEmitter = eventEmitter;
  }

  async onEvent(event) {
    try {
      console.log(event);
      
      this.eventEmitter.emit('event', event);
      // Retrieve events that are denoted with 'requires_action' since these will have our tool_calls
      if (event.event === "thread.run.requires_action") {
        await this.handleRequiresAction(
          event.data,
          event.data.id,
          event.data.thread_id,
        );
      }
    } catch (error) {
      console.error("Error handling event:", error);
    }
  }

  async handleRequiresAction(data, runId, threadId) {
    try {
      const toolOutputs = [];
      for (let toolCall of data.required_action.submit_tool_outputs.tool_calls) {
        if (toolCall.function.name === "lookUpTime") {
          const args = JSON.parse(toolCall.function.arguments);
          const time = await lookUpTime(args.location);
          toolOutputs.push({ tool_call_id: toolCall.id, output: time });
        }
      }
      // Submit all the tool outputs at the same time
      await this.submitToolOutputs(toolOutputs, runId, threadId);
    } catch (error) {
      console.error("Error processing required action:", error);
    }
  }

  async submitToolOutputs(toolOutputs, runId, threadId) {
    try {
      // Use the submitToolOutputsStream helper
      const stream = this.client.beta.threads.runs.submitToolOutputsStream(
        threadId,
        runId,
        { tool_outputs: toolOutputs },
      );
      for await (const event of stream) {
        this.emit("event", event);
      }
    } catch (error) {
      console.error("Error submitting tool outputs:", error);
    }
  }
}

const runAssistant = async (id, mainPrompt, eventEmitter) => {
  try {
    const thread  = await openai.beta.threads.create();
    const message = await openai.beta.threads.messages.create(
      thread.id,
      {
        role: "user",
        content: mainPrompt
      }
    );
    const eventHandler = new EventHandler(openai, eventEmitter);
    eventHandler.on("event", eventHandler.onEvent.bind(eventHandler));
    const run = openai.beta.threads.runs.stream (
      thread.id,
      {
        assistant_id: id,
        instructions: "You will teach the user how to solve it."
      },
      eventHandler,
    );
    for await (const event of run) {
      eventHandler.emit("event", event);
    }
      // & To here }
  } catch(err) {
    throw err;
  }
};

module.exports = {
  createAssistant,
  getAllPrompt,
  runAssistant,
};